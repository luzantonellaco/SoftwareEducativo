{% load static %}
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <title>Nivel 2: Capa de Transporte</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'aplicacion/niveles.css' %}">
    <link rel="stylesheet" href="{% static 'aplicacion/style.css' %}">
</head>
<body>
<!--     <div class="placeholder">
        <h1>Nivel 2 ‚Äî Capa de Transporte</h1>
        <p>Plantilla de marcador de posici√≥n. Aqu√≠ ir√° la actividad del Nivel 2.</p>
        <p><a href="{% url 'perfil_estudiante' %}" class="btn-menu">Volver al Perfil</a></p>
    </div> -->
    
    {% if user.is_authenticated %}
    
    <h1 class="title" style="margin-top: 30px; margin-bottom: 10px;">AVENTURA TCP/IP: CARRERA DE CAPAS üèÅ</h1>

    <div class="game-area">
        
        <div class="game-profile-meta">
            Jugando como: <strong>{{ user.alias|default:user.username }}</strong> | Rol: {{ user.rol }}
        </div>
        
        <h2 style="color: #0077B6; margin-bottom: 5px;">Nivel 2: Capa de Trasporte</h2>
        <p style="text-align: center; font-style: italic; margin-bottom: 15px;">Pregunta <span id="current-q-number">1</span> de 10. ¬°Cada acierto te acerca a la Fibra √ìptica!</p>
        
        <div class="progress-bar-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>

        <form id="quiz-form" onsubmit="return false;"> 
            <div id="questions-container">
                </div>
            
            <div id="score-results" style="display: none;">
                <div class="score-display">Puntuaci√≥n Final: <span id="final-score"></span>/10</div>
                <div id="feedback-final" class="feedback"></div>
                
                <div id="review-container">
                    <h4>Revisi√≥n Detallada (Aciertos y Errores)</h4>
                    <div id="review-list"></div>
                </div>
            </div>

            <div class="nav-controls">
                <button type="button" id="prev-btn" disabled>‚Üê Anterior</button>
                <button type="button" id="check-btn">Verificar</button>
                <button type="button" id="next-btn" disabled>Siguiente ‚Üí</button>
                <button type="button" id="finish-btn" style="display:none;">Finalizar</button>
            </div>
        </form>

        <a href="{% url 'perfil_estudiante' %}" class="link-return" style="display: block; margin-top: 20px;">Volver al Men√∫ de Niveles</a>
    </div>

    <script>
        // (Opcional) Rutas a im√°genes ‚Äî actualmente usamos emojis en la tarjeta
/*     const IMG_FIBRA = "{% static 'aplicacion/images/fibra.svg' %}";
    const IMG_CAT6 = "{% static 'aplicacion/images/cat6.svg' %}";
    const IMG_CAT35 = "{% static 'aplicacion/images/cat3_5.svg' %}"; */
        
        // --- DATOS DEL QUIZ (10 PREGUNTAS VARIADAS) ---

        //PREGUNTA 1
        const questions = [
           { id: 1, type: 'drag_drop', text: "P1. Unir cada elemento con su funci√≥n en la capa de transporte. (Arrastre)",

        drag_items: [

            { value: 'puerto_', label: 'N√∫mero de puerto' },

            { value: 'control_f', label: 'Control de flujo' },

            {value: 'segment_', label:'Segmentaci√≥n'}

        ],

        drop_zones: [

            { function: 'puerto', label: 'Identificador que permite dirigir los datos a la aplicaci√≥n correcta' },

            { function: 'controlf', label: 'Mecanismo que evita que el emisor sature al receptor' },

            {function: 'segment', label:'Proceso de dividir mensajes en unidades m√°s peque√±as para transmitir'}

        ],

        correct_map: {'puerto': 'puerto_', 'controlf': 'control_f', 'segment': 'segment_' },

        answer: {}, checked: false, score_value: 1

    },

    /* FALTA CAMBIAR DESDE AQUI  */
            // P2: DRAG & DROP (3 items) - Protocolo a Funci√≥n
            { id: 2, type: 'drag_drop', text: "P2. NO CAMBIE DESDE AQUI <<<<<<<<  Asocia cada Protocolo de Correo a su funci√≥n:",
                drag_items: [ { value: 'smtp', label: 'SMTP (Env√≠o)' }, { value: 'pop3', label: 'POP3 (Descarga)' }, { value: 'imap', label: 'IMAP (Gesti√≥n)' } ],
                drop_zones: [ { function: 'send_mail', label: 'Env√≠o de Correo' }, { function: 'download_mail', label: 'Descarga simple' }, { function: 'manage_mail', label: 'Gesti√≥n en Servidor' } ],
                correct_map: { 'send_mail': 'smtp', 'download_mail': 'pop3', 'manage_mail': 'imap' },
                answer: {}, checked: false, score_value: 1
            },
            
            // P3: DRAG & DROP (3 items) - Analog√≠a
            { id: 3, type: 'drag_drop', text: "P3. Si la red fuera un sistema de encomiendas, arrastra el elemento a su Capa correcta:",
                drag_items: [ { value: 'message', label: 'El Contenido (Mensaje)' }, { value: 'packet', label: 'El Repartidor (Ruta)' }, { value: 'courier', label: 'La Aplicaci√≥n (Usuario)' } ],
                drop_zones: [ { function: 'application', label: 'Capa de Aplicaci√≥n' }, { function: 'network', label: 'Capa de Red' }, { function: 'transport', label: 'Capa de Transporte' } ],
                correct_map: { 'application': 'courier', 'network': 'packet', 'transport': 'message' },
                answer: {}, checked: false, score_value: 1
            },

            // P4: VERDADERO/FALSO
            { id: 4, type: 'tf', text: "P4. V/F: El modelo TCP/IP de la IETF define cuatro capas, pero se usa la pila de cinco capas por razones pedag√≥gicas, separando Enlace y F√≠sica.", options: ['Verdadero', 'Falso'], correct_answer: 'Verdadero', explanation: "Verdadero. La divisi√≥n de Capa F√≠sica y Enlace se usa para facilitar la comprensi√≥n de la correspondencia con OSI.", answer: null, checked: false, score_value: 1 },

            // P5: OPCI√ìN M√öLTIPLE (Analog√≠a creativa)
            { id: 5, type: 'mc', text: "P5. Si la red fuera un sistema postal, la Capa de Aplicaci√≥n ser√≠a el equivalente a:", options: ['El cartero', 'La estampilla', 'La carta escrita (el mensaje)', 'El buz√≥n'], correct_answer: 'La carta escrita (el mensaje)', explanation: "Es donde el usuario interact√∫a, creando el mensaje o datos finales.", answer: null, checked: false, score_value: 1 },

            // P6: VERDADERO/FALSO (Funci√≥n)
            { id: 6, type: 'tf', text: "P6. V/F: Un navegador web y un servidor web (como Apache) son ejemplos de entidades de Capa de Aplicaci√≥n.", options: ['Verdadero', 'Falso'], correct_answer: 'Verdadero', explanation: "Verdadero. Son las aplicaciones que corren sobre la red, usando los protocolos de esta capa.", answer: null, checked: false, score_value: 1 },
            
            // P7: OPCI√ìN M√öLTIPLE (PDU)
            { id: 7, type: 'mc', text: "P7. ¬øCu√°l es la PDU principal (Unidad de Datos) que maneja la Capa de Aplicaci√≥n?", options: ['Segmentos', 'Tramas', 'Mensajes', 'Paquetes'], correct_answer: 'Mensajes', explanation: "La Capa de Aplicaci√≥n trabaja con 'Mensajes', datos a nivel de usuario.", answer: null, checked: false, score_value: 1 },

            // P8: VERDADERO/FALSO (Concepto final)
            { id: 8, type: 'tf', text: "P8. V/F: Un servicio de red 'persistente' es aquel que mantiene el estado entre transacciones (ej: FTP mantiene la conexi√≥n activa para m√∫ltiples transferencias).", options: ['Verdadero', 'Falso'], correct_answer: 'Verdadero', explanation: "Verdadero. Los protocolos persistentes (como FTP o HTTP 1.1 con *Keep-Alive*) mantienen la conexi√≥n para optimizar la comunicaci√≥n.", answer: null, checked: false, score_value: 1 },
            
            // P9: OPCI√ìN M√öLTIPLE (Puerto simple)
            { id: 9, type: 'mc', text: "P9. El protocolo utilizado para la navegaci√≥n web segura (HTTPS) usa el puerto:", options: ['21', '80', '443', '110'], correct_answer: '443', explanation: "HTTPS utiliza el puerto 443 por defecto para la comunicaci√≥n cifrada (TLS/SSL).", answer: null, checked: false, score_value: 1 },
            
            // P10: OPCI√ìN M√öLTIPLE (Analog√≠a creativa)
            { id: 10, type: 'mc', text: "P10. Si un protocolo de correo mantiene copias en el servidor (IMAP), ¬øcu√°l utiliza la descarga y eliminaci√≥n simple?", options: ['SMTP', 'IMAP', 'POP3', 'FTP'], correct_answer: 'POP3', explanation: "POP3 (Post Office Protocol 3) t√≠picamente descarga y elimina el correo del servidor.", answer: null, checked: false, score_value: 1 }

        ];

        let currentQuestionIndex = 0;
        let finalScore = 0; // Para rastrear la puntuaci√≥n total
        const questionsContainer = document.getElementById('questions-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const checkBtn = document.getElementById('check-btn');
        const finishBtn = document.getElementById('finish-btn');
        const scoreResults = document.getElementById('score-results');
        const currentQNumber = document.getElementById('current-q-number');
        const progressBar = document.getElementById('progress-bar');
        const reviewList = document.getElementById('review-list');
        
        // Verifica si la respuesta actual (guardada en q.answer) es correcta
        function normalizeVal(v) {
            if (v === null || v === undefined) return '';
            try { return String(v).trim().toLowerCase(); } catch(e) { return String(v); }
        }

        function checkCurrentAnswer(q) {
            if (q.type === 'drag_drop') {
                // Funci√≥n espec√≠fica para D&D: verifica si el n√∫mero de √≠tems colocados correctamente es igual al total de √≠tems
                const totalCorrectItems = Object.entries(q.correct_map).reduce((count, [zoneFunc, protocol]) => {
                    const given = q.answer && q.answer[zoneFunc];
                    return count + (normalizeVal(given) === normalizeVal(protocol) ? 1 : 0);
                }, 0);
                return totalCorrectItems === (q.drag_items || []).length; 
            } else {
                // Funci√≥n para MC/TF: verifica si la respuesta guardada coincide con la correcta (normalizada)
                return normalizeVal(q.answer) === normalizeVal(q.correct_answer);
            }
        }
        
        function updateNavControls() {
            // ... (Actualizaci√≥n de botones y navegaci√≥n)
            const q = questions[currentQuestionIndex];
            
            prevBtn.disabled = currentQuestionIndex === 0;

            if (currentQuestionIndex === questions.length - 1) {
                nextBtn.style.display = 'none';
                finishBtn.style.display = q.checked ? 'inline-block' : 'none'; 
            } else {
                nextBtn.style.display = q.checked ? 'inline-block' : 'none';
                finishBtn.style.display = 'none';
            }
            
            if (q.checked) {
                checkBtn.style.display = 'none';
                nextBtn.disabled = false; 
            } else {
                checkBtn.style.display = 'inline-block';
                nextBtn.disabled = true; 
                
                // Habilitar/Deshabilitar Verificar si hay respuesta
                const isAnswered = q.type === 'drag_drop' ? (Object.keys(q.answer).length === q.drag_items.length) : !!q.answer;
                checkBtn.disabled = !isAnswered; 
            }
        }
        
        function renderQuestion(index) {
            // ... (Renderiza la pregunta actual y sus elementos)
            questionsContainer.innerHTML = '';
            const q = questions[index];
            let html = `<div class="question-module active" data-qid="${q.id}">`;
            html += `<h4 style="font-size: 1.3em;">${q.text}</h4>`;
            
            if (q.type === 'drag_drop') {
                html += renderDragDrop(q);
            } else {
                html += renderOptions(q);
            }
            
            html += `<div id="q-feedback-${q.id}" class="feedback-message" style="display:none;"></div>`;

            html += `</div>`;
            questionsContainer.innerHTML = html;
            
            if (q.type === 'drag_drop') {
                setupDragDropListeners();
                restoreDragDropState(q);
            }

            applyQuestionState(q);

            currentQNumber.textContent = index + 1;
            const progress = ((index + 1) / questions.length) * 100;
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `${Math.round(progress)}%`;
            
            updateNavControls();
        }

/*         function renderDragDrop(q) {
            // ... (Funci√≥n de renderizado de D&D)
            let ddHtml = '';
            let dragItemsHtml = '';
            
            q.drag_items.forEach(item => {
                dragItemsHtml += `<div class="draggable" draggable="true" data-protocol="${item.value}">${item.label}</div>`;
            });
            
            ddHtml += `<div class="drag-container" id="drag-1">${dragItemsHtml}</div>`;
            
            ddHtml += `<div class="drop-container" id="drop-1">`;
            q.drop_zones.forEach(zone => {
                ddHtml += `<div class="dropzone" data-function="${zone.function}">${zone.label}</div>`;
            });
            ddHtml += `</div>`;
            return ddHtml;
        } */


        function renderDragDrop(q) {
    // üîπ Clonar y mezclar aleatoriamente las zonas de destino (definiciones)
    const shuffledZones = [...q.drop_zones].sort(() => Math.random() - 0.5);

    // Crear los elementos arrastrables (se mantienen igual)
    const dragHTML = `
      <div class="drag-column">
        ${q.drag_items.map(item => `
          <div class="draggable" draggable="true" data-protocol="${item.value}">
            ${item.label}
          </div>`).join('')}
      </div>`;

    // Crear las zonas de destino con el orden mezclado
    const dropHTML = `
      <div class="drop-column">
        ${shuffledZones.map(zone => `
          <div class="dropzone" data-function="${zone.function}">
            ${zone.label}
          </div>`).join('')}
      </div>`;

    // Estructura final (misma disposici√≥n)
    return `
      <div class="dragdrop-container" data-qid="${q.id}">
        ${dragHTML}
        ${dropHTML}
      </div>
    `;
}


        function renderOptions(q) {
            // ... (Funci√≥n de renderizado de opciones)
            const options = q.options;
            let optHtml = `<div class="options-group" data-qtype="${q.type}" data-correct="${q.correct_answer}">`;
            options.forEach(opt => {
                const isSelected = normalizeVal(q.answer) === normalizeVal(opt) ? 'selected' : '';
                optHtml += `<div class="option-btn ${isSelected}" data-value="${opt}" onclick="selectOption(this, ${q.id})">${opt}</div>`;
            });
            optHtml += `<div class="explanation" style="display:none; color: #0077B6; font-weight: 500; font-size: 0.9em; margin-top: 10px;">${q.explanation}</div>`;
            optHtml += `</div>`;
            return optHtml;
        }
        
        function applyQuestionState(q) {
            // ... (Aplica estado y feedback visual)
            const isChecked = q.checked;
            const qElement = document.querySelector(`[data-qid="${q.id}"]`);
            const feedbackBox = document.getElementById(`q-feedback-${q.id}`);
            
            // 1. Aplicar estado visual y deshabilitar opciones/drag
            if (q.type !== 'drag_drop') {
                const optionsGroup = qElement.querySelector('.options-group');
                optionsGroup.querySelectorAll('.option-btn').forEach(btn => {
                    if (normalizeVal(q.answer) === normalizeVal(btn.dataset.value)) {
                        btn.classList.add('selected');
                    }
                    if (isChecked) {
                        btn.style.pointerEvents = 'none';
                        if (normalizeVal(btn.dataset.value) === normalizeVal(q.correct_answer)) {
                            btn.classList.add('correct');
                        } else if (normalizeVal(btn.dataset.value) === normalizeVal(q.answer)) {
                            btn.classList.add('incorrect');
                        }
                    } else if (q.answer === btn.dataset.value) {
                         btn.classList.add('selected');
                    }
                });
            } else {
                // Estado para D&D
                if (isChecked) {
                    qElement.querySelectorAll('.draggable').forEach(item => { item.setAttribute('draggable', 'false'); });
                    qElement.querySelectorAll('.dropzone').forEach(zone => { zone.style.pointerEvents = 'none'; });
                    
                    const ddMap = q.correct_map;
                    qElement.querySelectorAll('.dropzone').forEach(zone => {
                        const droppedItem = zone.querySelector('.draggable');
                        // eliminar badges/etiquetas previas
                        const prevCorrect = zone.querySelector('.correct-answer');
                        if (prevCorrect) prevCorrect.remove();
                        if (droppedItem) {
                            // eliminar badge previo en el item
                            const oldBadge = droppedItem.querySelector('.dd-badge');
                            if (oldBadge) oldBadge.remove();

                            const isCorrect = droppedItem.dataset.protocol === ddMap[zone.dataset.function];
                            droppedItem.classList.add(isCorrect ? 'correct' : 'incorrect');

                            // A√±adir badge visual al √≠tem
                            const badge = document.createElement('span');
                            badge.className = 'dd-badge ' + (isCorrect ? 'dd-correct' : 'dd-incorrect');
                            badge.textContent = isCorrect ? '‚úì' : '‚úñ';
                            droppedItem.appendChild(badge);

                            // Si est√° incorrecto, mostrar la respuesta correcta bajo la zona
                            if (!isCorrect) {
                                const correctProtocol = ddMap[zone.dataset.function];
                                // buscar la etiqueta legible del item correcto
                                const correctLabel = (q.drag_items || []).find(it => it.value === correctProtocol);
                                const labelText = correctLabel ? correctLabel.label : correctProtocol;
                                const correctEl = document.createElement('div');
                                correctEl.className = 'correct-answer';
                                correctEl.textContent = 'Correcto: ' + labelText;
                                zone.appendChild(correctEl);
                            }
                        }
                    });
                }
            }
            
            // 2. Mostrar feedback de la pregunta si ya fue verificada
            if (isChecked) {
                const isCorrect = checkCurrentAnswer(q);
                let explanation = q.explanation || '';

                if (q.type === 'drag_drop') {
                    explanation = isCorrect ? '¬°Excelente! Todos los elementos est√°n en su lugar.' : 'Los √≠tems en rojo est√°n incorrectos. Revisa la correspondencia entre zonas y elementos arrastrados.';
                }

                feedbackBox.style.display = 'block';
                feedbackBox.className = 'feedback-message ' + (isCorrect ? 'correct' : 'incorrect');
                feedbackBox.innerHTML = (isCorrect ? '‚úÖ ¬°Respuesta Correcta!' : '‚ùå Incorrecto.') + 
                                       (explanation ? ('<br><em>Explicaci√≥n: ' + explanation + '</em>') : '');
            }
        }
        
        // --- L√ìGICA DE DRAG & DROP ESTADO/LISTENERS ---

        let draggedItem = null;
        function setupDragDropListeners() {
            // ... (setup D&D listeners)
             document.querySelectorAll('.draggable').forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = e.target;
                    e.dataTransfer.setData('text/plain', e.target.dataset.protocol);
                    setTimeout(() => e.target.style.opacity = 0.5, 0);
                });
                item.addEventListener('dragend', (e) => e.target.style.opacity = 1);
            });

            document.querySelectorAll('.dropzone').forEach(zone => {
                zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('hover'); });
                zone.addEventListener('dragleave', (e) => zone.classList.remove('hover'));
                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.classList.remove('hover');
                    
                    const existingDraggable = zone.querySelector('.draggable');
                    if(existingDraggable) { document.getElementById('drag-1').appendChild(existingDraggable); }
                    zone.appendChild(draggedItem);
                    
                    saveDragDropState();
                    checkBtn.disabled = false; 
                });
            });
        }
        
        function saveDragDropState() {
            // ... (save D&D state)
            const ddAnswer = {};
            document.querySelectorAll('.dropzone').forEach(zone => {
                const droppedItem = zone.querySelector('.draggable');
                if (droppedItem) {
                    ddAnswer[zone.dataset.function] = droppedItem.dataset.protocol;
                }
            });
            questions[currentQuestionIndex].answer = ddAnswer; 
            updateNavControls();
        }

        function restoreDragDropState(q) {
            // ... (restore D&D state)
            const qElement = document.querySelector(`[data-qid="${q.id}"]`);
            const dragContainer = qElement.querySelector('.drag-container');
            
            qElement.querySelectorAll('.dropzone .draggable').forEach(item => {
                 dragContainer.appendChild(item);
            });
            
            for (const [zoneFunc, protocol] of Object.entries(q.answer)) {
                const zone = qElement.querySelector(`.dropzone[data-function="${zoneFunc}"]`);
                const item = qElement.querySelector(`.draggable[data-protocol="${protocol}"]`);
                if (zone && item) {
                    zone.appendChild(item);
                }
            }
        }


        // --- L√ìGICA DE SELECCI√ìN DE OPCI√ìN (MC/TF) ---
        window.selectOption = function(btn, qid) {
            const q = questions[qid - 1];
            if (q.checked) return; 
            
            const container = btn.closest('.options-group');
            container.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            
            // Guardar la respuesta normalizada (pero mantener el valor original si se necesita)
            q.answer = btn.dataset.value ? btn.dataset.value.trim() : btn.dataset.value;
            checkBtn.disabled = false;
        }

        // --- EVENTO DE VERIFICACI√ìN POR PREGUNTA (MC/TF/D&D) ---
        checkBtn.addEventListener('click', () => {
            const q = questions[currentQuestionIndex];
            
            if (!q.answer && q.type !== 'drag_drop') {
                 alert('¬°Debes seleccionar una opci√≥n para verificar!');
                 return;
            }
            if (q.type === 'drag_drop' && Object.keys(q.answer).length < q.drag_items.length) {
                 if (!confirm('No has colocado todos los √≠tems. ¬øDeseas verificar con el estado actual?')) {
                     return;
                 }
            }

            if (!q.checked) {
                if (checkCurrentAnswer(q)) {
                     finalScore++;
                }
                q.checked = true;
            }
            
            renderQuestion(currentQuestionIndex); 
        });


        // --- L√ìGICA DE NAVEGACI√ìN Y FINALIZACI√ìN ---
        
        nextBtn.addEventListener('click', () => {
            if (!questions[currentQuestionIndex].checked) {
                alert('¬°Debes verificar tu respuesta antes de avanzar!');
                return;
            }
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                renderQuestion(currentQuestionIndex);
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                renderQuestion(currentQuestionIndex);
            }
        });

        document.getElementById('finish-btn').addEventListener('click', function(e) {
            e.preventDefault();
            
            // L√≥gica de verificaci√≥n final y resumen (mantenemos el c√≥digo anterior)
            const lastQ = questions[questions.length - 1];
            if (!lastQ.checked) {
                 const isCorrect = checkCurrentAnswer(lastQ);
                 lastQ.checked = true;
                 if (isCorrect) finalScore++;
            }

            // Generar Retroalimentaci√≥n Detallada (Revisi√≥n)
            reviewList.innerHTML = '';
            questions.forEach((q) => {
                let isCorrect = checkCurrentAnswer(q);
                let userAnswerDisplay = q.type === 'drag_drop' ? `(Arrastradas: ${Object.keys(q.answer).length}/${q.drag_items.length})` : q.answer || 'No respondida';
                
                let reviewHtml = `<div class="review-item ${isCorrect ? 'correct-review' : 'incorrect-review'}">`;
                reviewHtml += `<strong>P${q.id}. ${q.text}</strong>`;
                reviewHtml += `<p class="user-answer">Tu Respuesta: ${userAnswerDisplay}</p>`;
                
                if (!isCorrect) {
                    reviewHtml += `<p class="correct-answer">Respuesta Correcta: ${q.correct_answer || 'Revisa el mapa de Puertos/Funciones.'}</p>`;
                    reviewHtml += `<p class="explanation-text">Explicaci√≥n: ${q.explanation}</p>`;
                }
                reviewHtml += `</div>`;
                reviewList.innerHTML += reviewHtml;
            });

            // Determinar R√∫brica de Desempe√±o y mostrar tarjeta llamativa
            let rubric = '';
            const score = finalScore;
            let icon = 'üéØ';
            let bgColor = '#28A745';
            let title = '';

            if (score >= 9) {
                rubric = 'Fibra √≥ptica (Excelente): Domina completamente los conceptos. ¬°Nivel Desbloqueado!';
                title = '¬°Excelente trabajo!';
                icon = 'üåü';
                bgColor = '#0f9d58';
            } else if (score >= 7) {
                rubric = 'UTP Cat 6 (Bueno): Comprende la mayor√≠a de los conceptos. ¬°Sigue as√≠!';
                title = 'Muy bien hecho';
                icon = 'üéâ';
                bgColor = '#029ad6';
            } else {
                rubric = 'UTP Cat 3/5 (Necesita Mejorar): Muestra dificultades. Te recomendamos estudiar y reintentar.';
                title = '¬°A mejorar!';
                icon = 'üîß';
                bgColor = '#ff6b6b';
            }

            // Mostrar r√∫brica detallada (icono o imagen, t√≠tulo, badge de score, clasificaci√≥n y sugerencias)
            const imgSrc = score >= 9 ? IMG_FIBRA : (score >= 7 ? IMG_CAT6 : IMG_CAT35);
            let cardHtml = `
                <div class="rubric-card" role="region" aria-label="Resultado final">
                    <div class="rubric-icon" style="background:${bgColor};">
                        <img src="${imgSrc}" alt="icono" onerror="this.style.display='none'; this.parentNode.textContent='${icon}';">
                    </div>
                    <div class="rubric-body">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
                            <div>
                                <div class="rubric-title">${title} <span class="rubric-score-badge">${score}/10</span></div>
                                <div class="rubric-text"><strong>Clasificaci√≥n:</strong> ${rubric}</div>
                            </div>
                        </div>
                        <div class="rubric-suggestion">Sugerencia: ${score >= 7 ? 'Revisa los conceptos avanzados y prueba el siguiente nivel.' : 'Repasa los temas con m√°s dificultades y vuelve a intentar. ¬°T√∫ puedes!'}</div>
                        <div class="rubric-cta">
                            <button type="button" class="btn-retry" onclick="location.reload();">üîÅ Reintentar</button>
                            <a href="/perfil/estudiante/" class="btn-menu" role="button" onclick="(function(e){ e.preventDefault(); window.location.href='/perfil/estudiante/'; })(event);">üè† Volver al Men√∫</a>
                        </div>
                    </div>
                </div>
            `;

            // Si el usuario obtuvo m√°s de 7 aciertos, desbloqueamos Nivel 2 (persistente en localStorage y en servidor)
            const shouldUnlock = score > 7; // usuario pidi√≥ "si saco mas de 7"
            if (shouldUnlock) {
                try { localStorage.setItem('unlocked_level_2', 'true'); } catch(e) { /* ignore if storage blocked */ }
                // No a√±adimos CTA extra: el perfil mostrar√° Nivel 2 desbloqueado server-side
            }

            // Env√≠o de resultados al servidor para persistencia (intentamos siempre, si hay sesi√≥n activa)
            (function sendResultsToServer(){
                try {
                    // Construir payload con respuestas m√≠nimas
                    const answersPayload = questions.map(q => ({ id: q.id, type: q.type, answer: q.answer }));

                    // Obtener csrf token desde cookie
                    function getCookie(name) {
                        const value = `; ${document.cookie}`;
                        const parts = value.split(`; ${name}=`);
                        if (parts.length === 2) return parts.pop().split(';').shift();
                    }
                    const csrftoken = getCookie('csrftoken');

                    fetch("{% url 'save_quiz_result' %}", {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrftoken || ''
                        },
                        body: JSON.stringify({ score: score, level: 1, answers: answersPayload })
                    }).then(res => {
                        if (!res.ok) console.warn('No se pudo guardar resultado en servidor');
                        return res.json();
                    }).then(data => {
                        // opcional: mostrar link r√°pido al intento guardado
                        if (data && data.attempt_id) {
                            // opcional: podr√≠amos mostrar el id en la UI
                        }
                    }).catch(err => {
                        console.warn('Error enviando resultados:', err);
                    });
                } catch(e) {
                    console.warn('No se pudo enviar resultados al servidor', e);
                }
            })();

            // cerrar body/card
            cardHtml += `
                    </div>
                </div>
            `;

            document.getElementById('feedback-final').innerHTML = cardHtml;

            // Si desbloqueamos Nivel 2, a√±adimos un bot√≥n est√©tico y centrado que lleve al perfil
            if (shouldUnlock) {
                try {
                    const btnHtml = `\n                        <div style="text-align:center; margin-top:14px;">\n                            <a href="{% url 'perfil_estudiante' %}" class="btn-go-profile">‚û°Ô∏è Ir al Perfil ‚Äî Nivel 2</a>\n                        </div>\n                    `;
                    document.getElementById('feedback-final').insertAdjacentHTML('beforeend', btnHtml);
                } catch(e) { console.warn('No se pudo a√±adir el bot√≥n de perfil', e); }
            }

            // Ocultar juego y mostrar resultados
            document.getElementById('questions-container').style.display = 'none';
            document.querySelector('.nav-controls').style.display = 'none';
            scoreResults.style.display = 'block';
            document.getElementById('final-score').textContent = finalScore;
            document.getElementById('finish-btn').disabled = true;
        });


        // Cargar la primera pregunta al inicio
        renderQuestion(currentQuestionIndex);
        
    </script>
    {% else %}
        <h1>Acceso Denegado</h1>
        <p>Necesitas iniciar sesi√≥n para ver esta p√°gina.</p>
    </div>
    {% endif %}
</body>
</html>

</body>
</html>
